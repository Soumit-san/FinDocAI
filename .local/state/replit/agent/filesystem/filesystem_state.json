{"file_contents":{"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nimport json\n\nfrom financial_analyzer import FinancialAnalyzer\nfrom market_data import MarketDataService\nfrom document_parser import DocumentParser\nfrom investment_strategy import InvestmentStrategy\n\n# Initialize services\n@st.cache_resource\ndef init_services():\n    analyzer = FinancialAnalyzer()\n    market_service = MarketDataService()\n    doc_parser = DocumentParser()\n    investment_strategy = InvestmentStrategy()\n    return analyzer, market_service, doc_parser, investment_strategy\n\ndef main():\n    st.set_page_config(\n        page_title=\"FinDocAI - Financial Document Analysis\",\n        page_icon=\"üìä\",\n        layout=\"wide\",\n        initial_sidebar_state=\"expanded\"\n    )\n    \n    st.title(\"üè¶ FinDocAI - AI-Powered Financial Document Analysis\")\n    st.markdown(\"Upload financial documents and get AI-powered insights, forecasts, and investment recommendations\")\n    \n    # Initialize services\n    analyzer, market_service, doc_parser, investment_strategy = init_services()\n    \n    # Sidebar for navigation\n    st.sidebar.title(\"Navigation\")\n    tab_selection = st.sidebar.selectbox(\n        \"Choose Analysis Type\",\n        [\"Document Upload & Q&A\", \"Market Analysis\", \"Investment Strategy\", \"Portfolio Dashboard\"]\n    )\n    \n    if tab_selection == \"Document Upload & Q&A\":\n        document_qa_tab(analyzer, doc_parser)\n    elif tab_selection == \"Market Analysis\":\n        market_analysis_tab(market_service, analyzer)\n    elif tab_selection == \"Investment Strategy\":\n        investment_strategy_tab(investment_strategy, market_service)\n    else:\n        portfolio_dashboard_tab(market_service, investment_strategy)\n\ndef document_qa_tab(analyzer, doc_parser):\n    st.header(\"üìÑ Document Analysis & Q&A\")\n    \n    # Document upload\n    uploaded_file = st.file_uploader(\n        \"Upload Financial Document\",\n        type=['pdf', 'txt', 'docx'],\n        help=\"Upload earnings reports, financial filings, or press releases (Max 50MB)\"\n    )\n    \n    if uploaded_file is not None:\n        # Display file info\n        st.info(f\"üìé Uploaded: {uploaded_file.name} ({uploaded_file.size / (1024*1024):.1f} MB)\")\n        \n        # Parse document\n        with st.spinner(\"Parsing document...\"):\n            try:\n                document_text = doc_parser.parse_document(uploaded_file)\n                st.session_state['document_text'] = document_text\n                st.success(\"‚úÖ Document parsed successfully!\")\n                \n                # Show document preview\n                with st.expander(\"üìñ Document Preview\"):\n                    st.text_area(\"Document Content (First 1000 characters)\", \n                                document_text[:1000] + \"...\" if len(document_text) > 1000 else document_text,\n                                height=200, disabled=True)\n                \n            except Exception as e:\n                st.error(f\"‚ùå Error parsing document: {str(e)}\")\n                return\n        \n        # Document Analysis\n        st.subheader(\"üîç Quick Analysis\")\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            if st.button(\"üìä Analyze Sentiment\", key=\"sentiment_btn\"):\n                with st.spinner(\"Analyzing sentiment...\"):\n                    sentiment_result = analyzer.analyze_sentiment(document_text)\n                    \n                    sentiment_color = {\n                        'positive': 'green',\n                        'negative': 'red', \n                        'neutral': 'gray'\n                    }\n                    \n                    st.metric(\n                        \"Sentiment\",\n                        sentiment_result['sentiment'].title(),\n                        delta=f\"Confidence: {sentiment_result['confidence']:.1%}\"\n                    )\n                    \n                    # Sentiment visualization\n                    fig = go.Figure(go.Indicator(\n                        mode=\"gauge+number\",\n                        value=sentiment_result['score'],\n                        domain={'x': [0, 1], 'y': [0, 1]},\n                        title={'text': \"Sentiment Score\"},\n                        gauge={\n                            'axis': {'range': [-1, 1]},\n                            'bar': {'color': sentiment_color[sentiment_result['sentiment']]},\n                            'steps': [\n                                {'range': [-1, -0.3], 'color': \"lightcoral\"},\n                                {'range': [-0.3, 0.3], 'color': \"lightgray\"},\n                                {'range': [0.3, 1], 'color': \"lightgreen\"}\n                            ]\n                        }\n                    ))\n                    fig.update_layout(height=300)\n                    st.plotly_chart(fig, use_container_width=True)\n        \n        with col2:\n            if st.button(\"‚ö†Ô∏è Detect Anomalies\", key=\"anomaly_btn\"):\n                with st.spinner(\"Detecting anomalies...\"):\n                    anomalies = analyzer.detect_anomalies(document_text)\n                    \n                    if anomalies['anomalies_found']:\n                        st.warning(f\"‚ö†Ô∏è {len(anomalies['anomalies'])} anomalies detected\")\n                        for i, anomaly in enumerate(anomalies['anomalies'], 1):\n                            st.write(f\"{i}. **{anomaly['type']}**: {anomaly['description']}\")\n                            st.write(f\"   *Severity: {anomaly['severity']}/10*\")\n                    else:\n                        st.success(\"‚úÖ No significant anomalies detected\")\n        \n        # Q&A Section\n        st.subheader(\"üí¨ Ask Questions About Your Document\")\n        \n        # Predefined questions\n        st.write(\"**Quick Questions:**\")\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            if st.button(\"üìà What's the revenue?\"):\n                st.session_state['user_question'] = \"What is the company's revenue for this period?\"\n        \n        with col2:\n            if st.button(\"‚ö†Ô∏è What are the risks?\"):\n                st.session_state['user_question'] = \"What are the main risks mentioned in this document?\"\n                \n        with col3:\n            if st.button(\"üìä Key metrics?\"):\n                st.session_state['user_question'] = \"What are the key financial metrics mentioned?\"\n        \n        # Custom question input\n        user_question = st.text_input(\n            \"Or ask your own question:\",\n            value=st.session_state.get('user_question', ''),\n            placeholder=\"e.g., What is the company's outlook for next quarter?\"\n        )\n        \n        if st.button(\"üîç Get Answer\") and user_question and 'document_text' in st.session_state:\n            with st.spinner(\"Analyzing document to answer your question...\"):\n                try:\n                    answer = analyzer.answer_question(st.session_state['document_text'], user_question)\n                    st.success(\"‚úÖ Analysis Complete\")\n                    st.write(\"**Answer:**\")\n                    st.write(answer['answer'])\n                    \n                    if answer.get('confidence'):\n                        st.write(f\"*Confidence: {answer['confidence']:.1%}*\")\n                        \n                    if answer.get('key_excerpts'):\n                        with st.expander(\"üìã Supporting Evidence\"):\n                            for excerpt in answer['key_excerpts']:\n                                st.write(f\"‚Ä¢ {excerpt}\")\n                                \n                except Exception as e:\n                    st.error(f\"‚ùå Error answering question: {str(e)}\")\n\ndef market_analysis_tab(market_service, analyzer):\n    st.header(\"üìà Market Analysis & Forecasting\")\n    \n    # Stock symbol input\n    col1, col2 = st.columns([2, 1])\n    with col1:\n        symbol = st.text_input(\"Enter Stock Symbol\", value=\"AAPL\", placeholder=\"e.g., AAPL, GOOGL, MSFT\")\n    with col2:\n        period = st.selectbox(\"Time Period\", [\"1mo\", \"3mo\", \"6mo\", \"1y\", \"2y\"])\n    \n    if st.button(\"üìä Analyze Stock\") and symbol:\n        try:\n            with st.spinner(f\"Fetching data for {symbol}...\"):\n                # Get market data\n                stock_data = market_service.get_stock_data(symbol, period)\n                company_info = market_service.get_company_info(symbol)\n                \n                if stock_data.empty:\n                    st.error(f\"‚ùå No data found for symbol: {symbol}\")\n                    return\n                \n                # Display company info\n                st.subheader(f\"üìä {company_info.get('longName', symbol)} Analysis\")\n                \n                col1, col2, col3, col4 = st.columns(4)\n                \n                current_price = stock_data['Close'].iloc[-1]\n                prev_price = stock_data['Close'].iloc[-2] if len(stock_data) > 1 else current_price\n                change = current_price - prev_price\n                change_pct = (change / prev_price) * 100 if prev_price != 0 else 0\n                \n                with col1:\n                    st.metric(\"Current Price\", f\"${current_price:.2f}\", f\"{change:+.2f} ({change_pct:+.1f}%)\")\n                \n                with col2:\n                    st.metric(\"Market Cap\", company_info.get('marketCap', 'N/A'))\n                \n                with col3:\n                    st.metric(\"P/E Ratio\", f\"{company_info.get('forwardPE', 'N/A'):.2f}\" if company_info.get('forwardPE') else 'N/A')\n                \n                with col4:\n                    st.metric(\"52W High\", f\"${company_info.get('fiftyTwoWeekHigh', 'N/A')}\")\n                \n                # Price chart\n                fig = go.Figure()\n                fig.add_trace(go.Scatter(\n                    x=stock_data.index,\n                    y=stock_data['Close'],\n                    mode='lines',\n                    name='Price',\n                    line=dict(color='blue', width=2)\n                ))\n                \n                fig.update_layout(\n                    title=f\"{symbol} Stock Price - {period}\",\n                    xaxis_title=\"Date\",\n                    yaxis_title=\"Price ($)\",\n                    hovermode='x unified'\n                )\n                \n                st.plotly_chart(fig, use_container_width=True)\n                \n                # Volume chart\n                fig_volume = go.Figure()\n                fig_volume.add_trace(go.Bar(\n                    x=stock_data.index,\n                    y=stock_data['Volume'],\n                    name='Volume',\n                    marker_color='orange'\n                ))\n                \n                fig_volume.update_layout(\n                    title=f\"{symbol} Trading Volume\",\n                    xaxis_title=\"Date\",\n                    yaxis_title=\"Volume\"\n                )\n                \n                st.plotly_chart(fig_volume, use_container_width=True)\n                \n                # Technical analysis\n                st.subheader(\"üîç Technical Analysis\")\n                with st.spinner(\"Performing technical analysis...\"):\n                    tech_analysis = analyzer.technical_analysis(stock_data)\n                    \n                    col1, col2 = st.columns(2)\n                    \n                    with col1:\n                        st.write(\"**Moving Averages:**\")\n                        for ma, value in tech_analysis['moving_averages'].items():\n                            st.write(f\"‚Ä¢ {ma}: ${value:.2f}\")\n                    \n                    with col2:\n                        st.write(\"**Technical Indicators:**\")\n                        st.write(f\"‚Ä¢ RSI: {tech_analysis['rsi']:.2f}\")\n                        st.write(f\"‚Ä¢ Volatility: {tech_analysis['volatility']:.2%}\")\n                        st.write(f\"‚Ä¢ Trend: {tech_analysis['trend']}\")\n                \n                # Forecasting\n                st.subheader(\"üîÆ Price Forecast\")\n                if st.button(\"Generate 30-Day Forecast\"):\n                    with st.spinner(\"Generating forecast...\"):\n                        forecast = analyzer.generate_forecast(stock_data, symbol)\n                        \n                        # Create forecast chart\n                        fig_forecast = go.Figure()\n                        \n                        # Historical data\n                        fig_forecast.add_trace(go.Scatter(\n                            x=stock_data.index,\n                            y=stock_data['Close'],\n                            mode='lines',\n                            name='Historical',\n                            line=dict(color='blue')\n                        ))\n                        \n                        # Forecast data\n                        fig_forecast.add_trace(go.Scatter(\n                            x=forecast['dates'],\n                            y=forecast['prices'],\n                            mode='lines+markers',\n                            name='Forecast',\n                            line=dict(color='red', dash='dash')\n                        ))\n                        \n                        fig_forecast.update_layout(\n                            title=f\"{symbol} Price Forecast (30 Days)\",\n                            xaxis_title=\"Date\",\n                            yaxis_title=\"Price ($)\"\n                        )\n                        \n                        st.plotly_chart(fig_forecast, use_container_width=True)\n                        \n                        # Forecast summary\n                        st.write(\"**Forecast Summary:**\")\n                        st.write(f\"‚Ä¢ Predicted price in 30 days: ${forecast['target_price']:.2f}\")\n                        st.write(f\"‚Ä¢ Expected return: {forecast['expected_return']:+.1%}\")\n                        st.write(f\"‚Ä¢ Confidence: {forecast['confidence']:.1%}\")\n                        st.write(f\"‚Ä¢ Risk level: {forecast['risk_level']}\")\n                \n        except Exception as e:\n            st.error(f\"‚ùå Error analyzing stock: {str(e)}\")\n\ndef investment_strategy_tab(investment_strategy, market_service):\n    st.header(\"üí∞ Investment Strategy & Recommendations\")\n    \n    # Portfolio input\n    st.subheader(\"üìù Portfolio Configuration\")\n    \n    # Add stocks to portfolio\n    if 'portfolio' not in st.session_state:\n        st.session_state.portfolio = []\n    \n    col1, col2, col3 = st.columns([2, 1, 1])\n    \n    with col1:\n        new_symbol = st.text_input(\"Add Stock Symbol\", placeholder=\"e.g., AAPL\")\n    with col2:\n        shares = st.number_input(\"Shares\", min_value=1, value=100)\n    with col3:\n        if st.button(\"‚ûï Add to Portfolio\"):\n            if new_symbol:\n                st.session_state.portfolio.append({\n                    'symbol': new_symbol.upper(),\n                    'shares': shares,\n                    'added_date': datetime.now()\n                })\n                st.success(f\"Added {new_symbol.upper()} to portfolio\")\n                st.rerun()\n    \n    # Display current portfolio\n    if st.session_state.portfolio:\n        st.subheader(\"üìä Current Portfolio\")\n        \n        portfolio_data = []\n        total_value = 0\n        \n        for item in st.session_state.portfolio:\n            try:\n                stock_data = market_service.get_stock_data(item['symbol'], '1d')\n                if not stock_data.empty:\n                    current_price = stock_data['Close'].iloc[-1]\n                    value = current_price * item['shares']\n                    total_value += value\n                    \n                    portfolio_data.append({\n                        'Symbol': item['symbol'],\n                        'Shares': item['shares'],\n                        'Current Price': f\"${current_price:.2f}\",\n                        'Value': f\"${value:.2f}\"\n                    })\n            except:\n                portfolio_data.append({\n                    'Symbol': item['symbol'],\n                    'Shares': item['shares'],\n                    'Current Price': 'Error',\n                    'Value': 'Error'\n                })\n        \n        df_portfolio = pd.DataFrame(portfolio_data)\n        st.dataframe(df_portfolio, use_container_width=True)\n        \n        st.metric(\"Total Portfolio Value\", f\"${total_value:.2f}\")\n        \n        # Clear portfolio button\n        if st.button(\"üóëÔ∏è Clear Portfolio\"):\n            st.session_state.portfolio = []\n            st.rerun()\n        \n        # Generate recommendations\n        if st.button(\"üéØ Generate Investment Recommendations\"):\n            with st.spinner(\"Analyzing portfolio and generating recommendations...\"):\n                try:\n                    recommendations = investment_strategy.generate_recommendations(st.session_state.portfolio, market_service)\n                    \n                    st.subheader(\"üéØ Investment Recommendations\")\n                    \n                    for rec in recommendations['recommendations']:\n                        # Create colored boxes for different recommendation types\n                        color_map = {\n                            'BUY': 'green',\n                            'SELL': 'red',\n                            'HOLD': 'gray'\n                        }\n                        \n                        st.markdown(f\"\"\"\n                        <div style=\"padding: 10px; margin: 5px 0; border-left: 5px solid {color_map.get(rec['action'], 'gray')}; background-color: rgba(128,128,128,0.1);\">\n                        <h4>{rec['symbol']} - {rec['action']}</h4>\n                        <p><strong>Confidence:</strong> {rec['confidence']:.1%}</p>\n                        <p><strong>Reasoning:</strong> {rec['reasoning']}</p>\n                        <p><strong>Target Price:</strong> ${rec['target_price']:.2f}</p>\n                        <p><strong>Risk Level:</strong> {rec['risk_level']}</p>\n                        </div>\n                        \"\"\", unsafe_allow_html=True)\n                    \n                    # Portfolio analysis\n                    st.subheader(\"üìà Portfolio Analysis\")\n                    \n                    col1, col2, col3 = st.columns(3)\n                    \n                    with col1:\n                        st.metric(\"Overall Score\", f\"{recommendations['portfolio_score']:.1f}/10\")\n                    \n                    with col2:\n                        st.metric(\"Risk Level\", recommendations['risk_assessment'])\n                    \n                    with col3:\n                        st.metric(\"Diversification\", recommendations['diversification_score'])\n                    \n                    # Recommendations summary\n                    st.write(\"**Portfolio Insights:**\")\n                    for insight in recommendations['insights']:\n                        st.write(f\"‚Ä¢ {insight}\")\n                \n                except Exception as e:\n                    st.error(f\"‚ùå Error generating recommendations: {str(e)}\")\n\ndef portfolio_dashboard_tab(market_service, investment_strategy):\n    st.header(\"üìä Portfolio Dashboard\")\n    \n    st.info(\"üí° This dashboard provides an overview of market trends and investment opportunities.\")\n    \n    # Market overview\n    st.subheader(\"üåç Market Overview\")\n    \n    # Major indices\n    indices = ['SPY', 'QQQ', 'IWM', 'VTI']\n    \n    cols = st.columns(len(indices))\n    \n    for i, index in enumerate(indices):\n        try:\n            with cols[i]:\n                data = market_service.get_stock_data(index, '5d')\n                if not data.empty:\n                    current = data['Close'].iloc[-1]\n                    prev = data['Close'].iloc[0]\n                    change_pct = ((current - prev) / prev) * 100\n                    \n                    st.metric(\n                        index,\n                        f\"${current:.2f}\",\n                        f\"{change_pct:+.1f}%\"\n                    )\n        except:\n            with cols[i]:\n                st.metric(index, \"Error\", \"N/A\")\n    \n    # Sector performance\n    st.subheader(\"üè≠ Sector Performance\")\n    \n    sector_etfs = {\n        'Technology': 'XLK',\n        'Healthcare': 'XLV', \n        'Financials': 'XLF',\n        'Energy': 'XLE',\n        'Consumer': 'XLY',\n        'Industrials': 'XLI'\n    }\n    \n    sector_data = []\n    for sector, etf in sector_etfs.items():\n        try:\n            data = market_service.get_stock_data(etf, '1mo')\n            if not data.empty:\n                current = data['Close'].iloc[-1]\n                start = data['Close'].iloc[0]\n                performance = ((current - start) / start) * 100\n                \n                sector_data.append({\n                    'Sector': sector,\n                    'ETF': etf,\n                    'Performance (1M)': f\"{performance:+.1f}%\",\n                    'Current Price': f\"${current:.2f}\"\n                })\n        except:\n            sector_data.append({\n                'Sector': sector,\n                'ETF': etf,\n                'Performance (1M)': 'Error',\n                'Current Price': 'Error'\n            })\n    \n    if sector_data:\n        df_sectors = pd.DataFrame(sector_data)\n        st.dataframe(df_sectors, use_container_width=True)\n    \n    # Market sentiment\n    st.subheader(\"üìä Market Sentiment Analysis\")\n    \n    if st.button(\"üìà Analyze Current Market Sentiment\"):\n        with st.spinner(\"Analyzing market sentiment...\"):\n            try:\n                # This would typically analyze news, social media, etc.\n                # For demo purposes, we'll show a simulated analysis\n                sentiment_data = {\n                    'overall_sentiment': 'Cautiously Optimistic',\n                    'sentiment_score': 0.65,\n                    'key_factors': [\n                        'Positive earnings reports from major tech companies',\n                        'Federal Reserve policy uncertainty',\n                        'Geopolitical tensions affecting energy markets',\n                        'Strong consumer spending data'\n                    ],\n                    'recommendation': 'Mixed signals suggest a balanced approach to portfolio allocation'\n                }\n                \n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.metric(\"Market Sentiment\", sentiment_data['overall_sentiment'])\n                    \n                    # Sentiment gauge\n                    fig = go.Figure(go.Indicator(\n                        mode=\"gauge+number\",\n                        value=sentiment_data['sentiment_score'],\n                        domain={'x': [0, 1], 'y': [0, 1]},\n                        title={'text': \"Sentiment Score\"},\n                        gauge={\n                            'axis': {'range': [0, 1]},\n                            'bar': {'color': \"lightblue\"},\n                            'steps': [\n                                {'range': [0, 0.3], 'color': \"lightcoral\"},\n                                {'range': [0.3, 0.7], 'color': \"lightyellow\"},\n                                {'range': [0.7, 1], 'color': \"lightgreen\"}\n                            ],\n                            'threshold': {\n                                'line': {'color': \"red\", 'width': 4},\n                                'thickness': 0.75,\n                                'value': 0.5\n                            }\n                        }\n                    ))\n                    fig.update_layout(height=300)\n                    st.plotly_chart(fig, use_container_width=True)\n                \n                with col2:\n                    st.write(\"**Key Market Factors:**\")\n                    for factor in sentiment_data['key_factors']:\n                        st.write(f\"‚Ä¢ {factor}\")\n                    \n                    st.write(\"**Recommendation:**\")\n                    st.info(sentiment_data['recommendation'])\n            \n            except Exception as e:\n                st.error(f\"‚ùå Error analyzing market sentiment: {str(e)}\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":24121},"document_parser.py":{"content":"import PyPDF2\nimport io\nimport docx\nimport pdfplumber\nfrom typing import Optional\n\nclass DocumentParser:\n    def __init__(self):\n        pass\n    \n    def parse_document(self, uploaded_file) -> str:\n        \"\"\"Parse uploaded documents and extract text content\"\"\"\n        try:\n            file_extension = uploaded_file.name.split('.')[-1].lower()\n            \n            if file_extension == 'pdf':\n                return self._parse_pdf(uploaded_file)\n            elif file_extension == 'txt':\n                return self._parse_txt(uploaded_file)\n            elif file_extension in ['docx', 'doc']:\n                return self._parse_docx(uploaded_file)\n            else:\n                raise ValueError(f\"Unsupported file format: {file_extension}\")\n                \n        except Exception as e:\n            raise Exception(f\"Error parsing document: {str(e)}\")\n    \n    def _parse_pdf(self, uploaded_file) -> str:\n        \"\"\"Parse PDF files with multiple extraction methods\"\"\"\n        try:\n            # Reset file pointer to beginning\n            uploaded_file.seek(0)\n            pdf_data = uploaded_file.read()\n            text_content = \"\"\n            \n            # Method 1: Try pdfplumber first (better for complex layouts and tables)\n            try:\n                pdf_file = io.BytesIO(pdf_data)\n                with pdfplumber.open(pdf_file) as pdf:\n                    for page_num, page in enumerate(pdf.pages):\n                        try:\n                            page_text = page.extract_text()\n                            if page_text:\n                                text_content += page_text + \"\\n\\n\"\n                                \n                            # Also extract text from tables if present\n                            tables = page.extract_tables()\n                            for table in tables:\n                                for row in table:\n                                    if row:\n                                        text_content += \" | \".join([cell or \"\" for cell in row]) + \"\\n\"\n                                text_content += \"\\n\"\n                                \n                        except Exception as page_error:\n                            print(f\"Warning: pdfplumber failed on page {page_num + 1}: {str(page_error)}\")\n                            continue\n                            \n                if text_content.strip():\n                    return text_content.strip()\n                    \n            except Exception as plumber_error:\n                print(f\"pdfplumber extraction failed: {str(plumber_error)}\")\n            \n            # Method 2: Fallback to PyPDF2 if pdfplumber fails\n            try:\n                pdf_file = io.BytesIO(pdf_data)\n                pdf_reader = PyPDF2.PdfReader(pdf_file)\n                \n                for page_num in range(len(pdf_reader.pages)):\n                    page = pdf_reader.pages[page_num]\n                    try:\n                        page_text = page.extract_text()\n                        if page_text:\n                            text_content += page_text + \"\\n\\n\"\n                    except Exception as page_error:\n                        print(f\"Warning: PyPDF2 failed on page {page_num + 1}: {str(page_error)}\")\n                        continue\n                        \n                if text_content.strip():\n                    return text_content.strip()\n                    \n            except Exception as pypdf_error:\n                print(f\"PyPDF2 extraction failed: {str(pypdf_error)}\")\n            \n            # If both methods fail\n            if not text_content.strip():\n                # Try to get basic info about the PDF\n                try:\n                    pdf_file = io.BytesIO(pdf_data)\n                    pdf_reader = PyPDF2.PdfReader(pdf_file)\n                    num_pages = len(pdf_reader.pages)\n                    \n                    if num_pages == 0:\n                        raise ValueError(\"PDF file appears to be empty or corrupted\")\n                    else:\n                        raise ValueError(\n                            f\"Could not extract text from PDF with {num_pages} pages. \"\n                            \"This might be a scanned PDF (image-based), encrypted, or have complex formatting. \"\n                            \"Try: 1) Converting to Word/text format, 2) Using OCR software, or 3) Uploading a different PDF.\"\n                        )\n                except:\n                    raise ValueError(\n                        \"PDF file could not be processed. It may be corrupted, encrypted, or in an unsupported format. \"\n                        \"Please try uploading a different file.\"\n                    )\n            \n            return text_content.strip()\n            \n        except Exception as e:\n            # More specific error handling\n            error_msg = str(e).lower()\n            if \"encrypted\" in error_msg or \"password\" in error_msg:\n                raise Exception(\"PDF is password protected. Please provide an unprotected PDF file.\")\n            elif \"corrupted\" in error_msg or \"invalid\" in error_msg:\n                raise Exception(\"PDF file appears to be corrupted. Please try uploading a different file.\")\n            else:\n                raise Exception(f\"Error parsing PDF: {str(e)}\")\n    \n    def _parse_txt(self, uploaded_file) -> str:\n        \"\"\"Parse text files\"\"\"\n        try:\n            # Read text file content\n            text_content = uploaded_file.read().decode('utf-8')\n            \n            if not text_content.strip():\n                raise ValueError(\"Text file appears to be empty\")\n            \n            return text_content\n            \n        except UnicodeDecodeError:\n            try:\n                # Try different encoding\n                uploaded_file.seek(0)\n                text_content = uploaded_file.read().decode('latin-1')\n                return text_content\n            except Exception as e:\n                raise Exception(f\"Error decoding text file: {str(e)}\")\n                \n        except Exception as e:\n            raise Exception(f\"Error parsing text file: {str(e)}\")\n    \n    def _parse_docx(self, uploaded_file) -> str:\n        \"\"\"Parse DOCX files\"\"\"\n        try:\n            # Create a BytesIO object from uploaded file\n            docx_file = io.BytesIO(uploaded_file.read())\n            \n            # Load document\n            doc = docx.Document(docx_file)\n            \n            text_content = \"\"\n            \n            # Extract text from paragraphs\n            for paragraph in doc.paragraphs:\n                text_content += paragraph.text + \"\\n\"\n            \n            # Extract text from tables\n            for table in doc.tables:\n                for row in table.rows:\n                    for cell in row.cells:\n                        text_content += cell.text + \"\\t\"\n                    text_content += \"\\n\"\n            \n            if not text_content.strip():\n                raise ValueError(\"No text content could be extracted from DOCX\")\n            \n            return text_content\n            \n        except Exception as e:\n            raise Exception(f\"Error parsing DOCX: {str(e)}\")\n    \n    def validate_financial_document(self, text_content: str) -> dict:\n        \"\"\"Validate if document appears to be financial in nature\"\"\"\n        try:\n            # Financial keywords to look for\n            financial_keywords = [\n                'revenue', 'earnings', 'profit', 'loss', 'balance sheet',\n                'income statement', 'cash flow', 'quarterly', 'annual',\n                'fiscal year', 'operating income', 'net income', 'ebitda',\n                'assets', 'liabilities', 'equity', 'dividend', 'shares',\n                'stock', 'investment', 'financial', 'sec filing', '10-k',\n                '10-q', '8-k', 'earnings report', 'financial statements'\n            ]\n            \n            text_lower = text_content.lower()\n            found_keywords = []\n            \n            for keyword in financial_keywords:\n                if keyword in text_lower:\n                    found_keywords.append(keyword)\n            \n            confidence_score = len(found_keywords) / len(financial_keywords)\n            is_financial = confidence_score > 0.1  # At least 10% of keywords found\n            \n            return {\n                'is_financial_document': is_financial,\n                'confidence_score': confidence_score,\n                'found_keywords': found_keywords,\n                'document_length': len(text_content),\n                'word_count': len(text_content.split())\n            }\n            \n        except Exception as e:\n            return {\n                'is_financial_document': False,\n                'confidence_score': 0.0,\n                'found_keywords': [],\n                'document_length': 0,\n                'word_count': 0,\n                'error': str(e)\n            }\n    \n    def extract_financial_metrics(self, text_content: str) -> dict:\n        \"\"\"Extract common financial metrics from document text\"\"\"\n        try:\n            import re\n            \n            metrics = {}\n            \n            # Common financial metric patterns\n            patterns = {\n                'revenue': r'revenue[s]?\\s*[:\\-]?\\s*\\$?([\\d,]+\\.?\\d*)\\s*(million|billion|thousand)?',\n                'net_income': r'net\\s+income[s]?\\s*[:\\-]?\\s*\\$?([\\d,]+\\.?\\d*)\\s*(million|billion|thousand)?',\n                'earnings_per_share': r'earnings?\\s+per\\s+share[s]?\\s*[:\\-]?\\s*\\$?([\\d,]+\\.?\\d*)',\n                'total_assets': r'total\\s+assets?\\s*[:\\-]?\\s*\\$?([\\d,]+\\.?\\d*)\\s*(million|billion|thousand)?',\n                'market_cap': r'market\\s+cap(?:italization)?\\s*[:\\-]?\\s*\\$?([\\d,]+\\.?\\d*)\\s*(million|billion|thousand)?'\n            }\n            \n            text_lower = text_content.lower()\n            \n            for metric, pattern in patterns.items():\n                matches = re.findall(pattern, text_lower)\n                if matches:\n                    # Take the first match\n                    amount, unit = matches[0]\n                    amount = amount.replace(',', '')\n                    \n                    # Convert to standard format\n                    try:\n                        value = float(amount)\n                        if unit.lower() == 'billion':\n                            value *= 1e9\n                        elif unit.lower() == 'million':\n                            value *= 1e6\n                        elif unit.lower() == 'thousand':\n                            value *= 1e3\n                        \n                        metrics[metric] = {\n                            'value': value,\n                            'formatted': f\"${value:,.2f}\",\n                            'original_text': matches[0]\n                        }\n                    except ValueError:\n                        continue\n            \n            return metrics\n            \n        except Exception as e:\n            return {'error': str(e)}\n    \n    def get_document_summary(self, text_content: str) -> dict:\n        \"\"\"Get summary statistics about the document\"\"\"\n        try:\n            words = text_content.split()\n            sentences = text_content.split('.')\n            \n            return {\n                'character_count': len(text_content),\n                'word_count': len(words),\n                'sentence_count': len(sentences),\n                'average_words_per_sentence': len(words) / len(sentences) if sentences else 0,\n                'estimated_reading_time_minutes': len(words) / 200,  # Average reading speed\n                'document_type': self._identify_document_type(text_content)\n            }\n            \n        except Exception as e:\n            return {'error': str(e)}\n    \n    def _identify_document_type(self, text_content: str) -> str:\n        \"\"\"Identify the type of financial document\"\"\"\n        text_lower = text_content.lower()\n        \n        document_types = {\n            '10-k': ['10-k', 'annual report', 'form 10-k'],\n            '10-q': ['10-q', 'quarterly report', 'form 10-q'],\n            '8-k': ['8-k', 'current report', 'form 8-k'],\n            'earnings_report': ['earnings report', 'quarterly earnings', 'earnings call'],\n            'press_release': ['press release', 'news release', 'announces'],\n            'analyst_report': ['analyst report', 'research report', 'price target'],\n            'proxy_statement': ['proxy statement', 'def 14a', 'shareholder meeting']\n        }\n        \n        for doc_type, keywords in document_types.items():\n            for keyword in keywords:\n                if keyword in text_lower:\n                    return doc_type.replace('_', ' ').title()\n        \n        return 'Financial Document'\n","size_bytes":12762},"financial_analyzer.py":{"content":"import json\nimport os\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport numpy as np\nimport google.generativeai as genai\n\nclass FinancialAnalyzer:\n    def __init__(self):\n        # Using Google Gemini API instead of OpenAI\n        genai.configure(api_key=os.getenv(\"GEMINI_API_KEY\"))\n        self.model = genai.GenerativeModel('gemini-pro')\n        \n    def analyze_sentiment(self, document_text):\n        \"\"\"Analyze sentiment of financial documents\"\"\"\n        try:\n            system_prompt = \"\"\"You are a financial sentiment analysis expert. Analyze the sentiment of financial documents and classify as positive, negative, or neutral. \n            Consider factors like:\n            - Revenue growth/decline\n            - Profit margins\n            - Market outlook statements\n            - Risk factors mentioned\n            - Management confidence\n            \n            Provide response in JSON format: {\n                \"sentiment\": \"positive|negative|neutral\",\n                \"confidence\": float between 0 and 1,\n                \"score\": float between -1 and 1,\n                \"key_phrases\": [\"phrase1\", \"phrase2\"],\n                \"reasoning\": \"explanation of analysis\"\n            }\"\"\"\n\n            prompt = f\"{system_prompt}\\n\\nAnalyze the sentiment of this financial document:\\n\\n{document_text[:4000]}\"\n            response = self.model.generate_content(prompt)\n            \n            result = json.loads(response.text)\n            return result\n            \n        except Exception as e:\n            return {\n                \"sentiment\": \"neutral\",\n                \"confidence\": 0.5,\n                \"score\": 0.0,\n                \"key_phrases\": [],\n                \"reasoning\": f\"Error in sentiment analysis: {str(e)}\"\n            }\n    \n    def detect_anomalies(self, document_text):\n        \"\"\"Detect anomalies in financial documents\"\"\"\n        try:\n            system_prompt = \"\"\"You are a financial anomaly detection expert. Analyze financial documents for unusual patterns, inconsistencies, or red flags.\n            \n            Look for:\n            - Unusual changes in financial metrics\n            - Inconsistent data or calculations\n            - Concerning risk factors\n            - Irregular accounting practices\n            - Significant one-time charges\n            - Management changes or governance issues\n            \n            Provide response in JSON format: {\n                \"anomalies_found\": boolean,\n                \"anomalies\": [\n                    {\n                        \"type\": \"category of anomaly\",\n                        \"description\": \"detailed description\",\n                        \"severity\": integer 1-10,\n                        \"recommendation\": \"what to investigate further\"\n                    }\n                ],\n                \"overall_risk\": \"low|medium|high\"\n            }\"\"\"\n\n            prompt = f\"{system_prompt}\\n\\nAnalyze this financial document for anomalies:\\n\\n{document_text[:4000]}\"\n            response = self.model.generate_content(prompt)\n            \n            result = json.loads(response.text)\n            return result\n            \n        except Exception as e:\n            return {\n                \"anomalies_found\": False,\n                \"anomalies\": [],\n                \"overall_risk\": \"unknown\",\n                \"error\": str(e)\n            }\n    \n    def answer_question(self, document_text, question):\n        \"\"\"Answer questions about financial documents using Q&A\"\"\"\n        try:\n            system_prompt = \"\"\"You are a financial document analysis expert. Answer questions about financial documents with precision and cite relevant information.\n            \n            When answering:\n            - Be specific and quantitative when possible\n            - Cite relevant numbers, percentages, or metrics\n            - Explain the context and significance\n            - If information is not available, state that clearly\n            - Provide confidence level in your answer\n            \n            Provide response in JSON format: {\n                \"answer\": \"detailed answer to the question\",\n                \"confidence\": float between 0 and 1,\n                \"key_excerpts\": [\"relevant text excerpts from document\"],\n                \"metrics_mentioned\": [\"specific numbers or percentages found\"],\n                \"data_availability\": \"complete|partial|insufficient\"\n            }\"\"\"\n\n            prompt = f\"{system_prompt}\\n\\nDocument:\\n{document_text[:4000]}\\n\\nQuestion: {question}\"\n            response = self.model.generate_content(prompt)\n            \n            result = json.loads(response.text)\n            return result\n            \n        except Exception as e:\n            return {\n                \"answer\": f\"Error processing question: {str(e)}\",\n                \"confidence\": 0.0,\n                \"key_excerpts\": [],\n                \"metrics_mentioned\": [],\n                \"data_availability\": \"error\"\n            }\n    \n    def technical_analysis(self, stock_data):\n        \"\"\"Perform technical analysis on stock data\"\"\"\n        try:\n            # Calculate moving averages\n            ma_20 = stock_data['Close'].rolling(window=20).mean().iloc[-1]\n            ma_50 = stock_data['Close'].rolling(window=50).mean().iloc[-1] if len(stock_data) >= 50 else None\n            ma_200 = stock_data['Close'].rolling(window=200).mean().iloc[-1] if len(stock_data) >= 200 else None\n            \n            # Calculate RSI\n            delta = stock_data['Close'].diff()\n            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n            rs = gain / loss\n            rsi = 100 - (100 / (1 + rs)).iloc[-1]\n            \n            # Calculate volatility\n            returns = stock_data['Close'].pct_change()\n            volatility = returns.std() * np.sqrt(252)  # Annualized volatility\n            \n            # Determine trend\n            current_price = stock_data['Close'].iloc[-1]\n            if ma_20 and current_price > ma_20:\n                if ma_50 and ma_20 > ma_50:\n                    trend = \"Strong Uptrend\"\n                else:\n                    trend = \"Uptrend\"\n            elif ma_20 and current_price < ma_20:\n                if ma_50 and ma_20 < ma_50:\n                    trend = \"Strong Downtrend\"\n                else:\n                    trend = \"Downtrend\"\n            else:\n                trend = \"Sideways\"\n            \n            moving_averages = {\"20-Day MA\": ma_20}\n            if ma_50:\n                moving_averages[\"50-Day MA\"] = ma_50\n            if ma_200:\n                moving_averages[\"200-Day MA\"] = ma_200\n            \n            return {\n                \"moving_averages\": moving_averages,\n                \"rsi\": rsi,\n                \"volatility\": volatility,\n                \"trend\": trend\n            }\n            \n        except Exception as e:\n            return {\n                \"moving_averages\": {},\n                \"rsi\": 50,\n                \"volatility\": 0,\n                \"trend\": \"Unknown\",\n                \"error\": str(e)\n            }\n    \n    def generate_forecast(self, stock_data, symbol):\n        \"\"\"Generate AI-powered price forecast\"\"\"\n        try:\n            # Prepare recent data for analysis\n            recent_data = stock_data.tail(30)  # Last 30 days\n            current_price = recent_data['Close'].iloc[-1]\n            \n            # Calculate basic statistics\n            avg_return = recent_data['Close'].pct_change().mean()\n            volatility = recent_data['Close'].pct_change().std()\n            volume_trend = recent_data['Volume'].pct_change().mean()\n            \n            # Create technical summary for AI analysis\n            tech_summary = f\"\"\"\n            Current Price: ${current_price:.2f}\n            Average Daily Return: {avg_return:.4f}\n            Volatility: {volatility:.4f}\n            Volume Trend: {volume_trend:.4f}\n            Recent High: ${recent_data['High'].max():.2f}\n            Recent Low: ${recent_data['Low'].min():.2f}\n            \"\"\"\n            \n            system_prompt = \"\"\"You are a financial forecasting expert. Based on recent stock performance data, generate a 30-day price forecast.\n            \n            Consider:\n            - Recent price trends and momentum\n            - Volatility patterns\n            - Trading volume changes\n            - Market conditions\n            \n            Provide a realistic forecast with JSON format: {\n                \"target_price\": float (price in 30 days),\n                \"expected_return\": float (percentage),\n                \"confidence\": float (0 to 1),\n                \"risk_level\": \"low|medium|high\",\n                \"key_factors\": [\"factor1\", \"factor2\"],\n                \"price_range\": {\"low\": float, \"high\": float}\n            }\"\"\"\n\n            prompt = f\"{system_prompt}\\n\\nGenerate 30-day forecast for {symbol} based on:\\n{tech_summary}\"\n            response = self.model.generate_content(prompt)\n            \n            result = json.loads(response.text)\n            \n            # Generate forecast dates and prices\n            forecast_dates = pd.date_range(\n                start=recent_data.index[-1] + timedelta(days=1),\n                periods=30,\n                freq='D'\n            )\n            \n            # Simple linear interpolation for visualization\n            start_price = current_price\n            end_price = result['target_price']\n            forecast_prices = np.linspace(start_price, end_price, 30)\n            \n            # Add some randomness based on volatility\n            np.random.seed(42)  # For reproducibility\n            noise = np.random.normal(0, volatility * start_price, 30)\n            forecast_prices = forecast_prices + noise\n            \n            result.update({\n                \"dates\": forecast_dates.tolist(),\n                \"prices\": forecast_prices.tolist()\n            })\n            \n            return result\n            \n        except Exception as e:\n            # Fallback forecast - define current_price if not available\n            try:\n                current_price = stock_data['Close'].iloc[-1]\n            except:\n                current_price = 100.0  # Fallback price\n                \n            return {\n                \"target_price\": current_price * 1.05,  # 5% increase\n                \"expected_return\": 0.05,\n                \"confidence\": 0.5,\n                \"risk_level\": \"medium\",\n                \"key_factors\": [\"Error in detailed analysis\"],\n                \"price_range\": {\"low\": current_price * 0.95, \"high\": current_price * 1.15},\n                \"dates\": pd.date_range(start=datetime.now() + timedelta(days=1), periods=30, freq='D').tolist(),\n                \"prices\": [current_price * (1 + 0.05 * i/30) for i in range(30)],\n                \"error\": str(e)\n            }\n","size_bytes":10866},"investment_strategy.py":{"content":"import json\nimport os\nfrom datetime import datetime, timedelta\nimport numpy as np\nimport google.generativeai as genai\n\nclass InvestmentStrategy:\n    def __init__(self):\n        # Using Google Gemini API instead of OpenAI\n        genai.configure(api_key=os.getenv(\"GEMINI_API_KEY\"))\n        self.model = genai.GenerativeModel('gemini-pro')\n        \n    def generate_recommendations(self, portfolio, market_service):\n        \"\"\"Generate investment recommendations based on portfolio and market data\"\"\"\n        try:\n            recommendations = []\n            portfolio_analysis = self._analyze_portfolio(portfolio, market_service)\n            \n            for stock in portfolio:\n                symbol = stock['symbol']\n                shares = stock['shares']\n                \n                # Get current market data\n                stock_data = market_service.get_stock_data(symbol, '3mo')\n                company_info = market_service.get_company_info(symbol)\n                \n                if stock_data.empty:\n                    continue\n                \n                # Analyze individual stock\n                stock_analysis = self._analyze_individual_stock(\n                    symbol, stock_data, company_info, market_service\n                )\n                \n                # Generate AI-powered recommendation\n                recommendation = self._generate_ai_recommendation(\n                    symbol, stock_analysis, portfolio_analysis\n                )\n                \n                recommendations.append(recommendation)\n            \n            # Overall portfolio assessment\n            overall_assessment = self._assess_portfolio_health(\n                portfolio, recommendations, market_service\n            )\n            \n            return {\n                'recommendations': recommendations,\n                'portfolio_score': overall_assessment['score'],\n                'risk_assessment': overall_assessment['risk_level'],\n                'diversification_score': overall_assessment['diversification'],\n                'insights': overall_assessment['insights']\n            }\n            \n        except Exception as e:\n            return {\n                'recommendations': [],\n                'portfolio_score': 5.0,\n                'risk_assessment': 'unknown',\n                'diversification_score': 'unknown',\n                'insights': [f'Error generating recommendations: {str(e)}']\n            }\n    \n    def _analyze_portfolio(self, portfolio, market_service):\n        \"\"\"Analyze overall portfolio characteristics\"\"\"\n        try:\n            sectors = {}\n            total_value = 0\n            portfolio_data = []\n            \n            for stock in portfolio:\n                symbol = stock['symbol']\n                shares = stock['shares']\n                \n                # Get company info for sector analysis\n                company_info = market_service.get_company_info(symbol)\n                stock_data = market_service.get_stock_data(symbol, '1d')\n                \n                if not stock_data.empty and 'currentPrice' in company_info:\n                    current_price = company_info.get('currentPrice', stock_data['Close'].iloc[-1])\n                    value = current_price * shares\n                    total_value += value\n                    \n                    sector = company_info.get('sector', 'Unknown')\n                    if sector not in sectors:\n                        sectors[sector] = 0\n                    sectors[sector] += value\n                    \n                    portfolio_data.append({\n                        'symbol': symbol,\n                        'shares': shares,\n                        'current_price': current_price,\n                        'value': value,\n                        'sector': sector,\n                        'company_info': company_info\n                    })\n            \n            # Calculate sector allocation percentages\n            sector_allocation = {}\n            for sector, value in sectors.items():\n                sector_allocation[sector] = (value / total_value) * 100 if total_value > 0 else 0\n            \n            return {\n                'total_value': total_value,\n                'stock_count': len(portfolio),\n                'sector_allocation': sector_allocation,\n                'portfolio_data': portfolio_data,\n                'diversification_score': self._calculate_diversification_score(sector_allocation)\n            }\n            \n        except Exception as e:\n            return {\n                'total_value': 0,\n                'stock_count': len(portfolio),\n                'sector_allocation': {},\n                'portfolio_data': [],\n                'diversification_score': 0,\n                'error': str(e)\n            }\n    \n    def _analyze_individual_stock(self, symbol, stock_data, company_info, market_service):\n        \"\"\"Analyze individual stock metrics\"\"\"\n        try:\n            current_price = stock_data['Close'].iloc[-1]\n            \n            # Price performance\n            price_30d_ago = stock_data['Close'].iloc[-30] if len(stock_data) >= 30 else stock_data['Close'].iloc[0]\n            price_performance_30d = ((current_price - price_30d_ago) / price_30d_ago) * 100\n            \n            # Volatility\n            returns = stock_data['Close'].pct_change().dropna()\n            volatility = returns.std() * np.sqrt(252)  # Annualized\n            \n            # Volume analysis\n            avg_volume = stock_data['Volume'].mean()\n            recent_volume = stock_data['Volume'].tail(5).mean()\n            volume_trend = ((recent_volume - avg_volume) / avg_volume) * 100\n            \n            # Technical indicators\n            ma_20 = stock_data['Close'].rolling(20).mean().iloc[-1]\n            ma_50 = stock_data['Close'].rolling(50).mean().iloc[-1] if len(stock_data) >= 50 else None\n            \n            # RSI calculation\n            delta = stock_data['Close'].diff()\n            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n            rs = gain / loss\n            rsi = 100 - (100 / (1 + rs)).iloc[-1]\n            \n            return {\n                'symbol': symbol,\n                'current_price': current_price,\n                'price_performance_30d': price_performance_30d,\n                'volatility': volatility,\n                'volume_trend': volume_trend,\n                'ma_20': ma_20,\n                'ma_50': ma_50,\n                'rsi': rsi,\n                'pe_ratio': company_info.get('forwardPE'),\n                'market_cap': company_info.get('marketCap'),\n                'sector': company_info.get('sector'),\n                'beta': company_info.get('beta'),\n                'dividend_yield': company_info.get('dividendYield')\n            }\n            \n        except Exception as e:\n            return {\n                'symbol': symbol,\n                'error': str(e)\n            }\n    \n    def _generate_ai_recommendation(self, symbol, stock_analysis, portfolio_analysis):\n        \"\"\"Generate AI-powered investment recommendation\"\"\"\n        try:\n            # Prepare analysis summary for AI\n            analysis_summary = f\"\"\"\n            Stock: {symbol}\n            Current Price: ${stock_analysis.get('current_price', 0):.2f}\n            30-day Performance: {stock_analysis.get('price_performance_30d', 0):.1f}%\n            Volatility: {stock_analysis.get('volatility', 0):.2f}\n            RSI: {stock_analysis.get('rsi', 50):.1f}\n            P/E Ratio: {stock_analysis.get('pe_ratio', 'N/A')}\n            Sector: {stock_analysis.get('sector', 'Unknown')}\n            Beta: {stock_analysis.get('beta', 'N/A')}\n            \n            Portfolio Context:\n            Total Portfolio Value: ${portfolio_analysis.get('total_value', 0):,.2f}\n            Portfolio Diversification Score: {portfolio_analysis.get('diversification_score', 0):.1f}/10\n            \"\"\"\n            \n            system_prompt = \"\"\"You are a professional investment advisor. Based on the stock analysis and portfolio context, provide investment recommendations.\n            \n            Consider:\n            - Technical indicators (RSI, moving averages, volatility)\n            - Fundamental metrics (P/E ratio, market cap, sector)\n            - Portfolio diversification needs\n            - Risk management principles\n            \n            Provide recommendations as BUY, SELL, or HOLD with clear reasoning.\n            \n            Respond in JSON format: {\n                \"action\": \"BUY|SELL|HOLD\",\n                \"confidence\": float (0 to 1),\n                \"target_price\": float,\n                \"reasoning\": \"detailed explanation\",\n                \"risk_level\": \"low|medium|high\",\n                \"time_horizon\": \"short|medium|long\",\n                \"key_factors\": [\"factor1\", \"factor2\"]\n            }\"\"\"\n\n            prompt = f\"{system_prompt}\\n\\nAnalyze and recommend action for:\\n{analysis_summary}\"\n            response = self.model.generate_content(prompt)\n            \n            result = json.loads(response.text)\n            result['symbol'] = symbol\n            \n            return result\n            \n        except Exception as e:\n            # Fallback recommendation\n            return {\n                'symbol': symbol,\n                'action': 'HOLD',\n                'confidence': 0.5,\n                'target_price': stock_analysis.get('current_price', 0),\n                'reasoning': f'Unable to generate detailed analysis: {str(e)}',\n                'risk_level': 'medium',\n                'time_horizon': 'medium',\n                'key_factors': ['Analysis error']\n            }\n    \n    def _assess_portfolio_health(self, portfolio, recommendations, market_service):\n        \"\"\"Assess overall portfolio health and provide insights\"\"\"\n        try:\n            # Calculate portfolio metrics\n            buy_count = sum(1 for rec in recommendations if rec['action'] == 'BUY')\n            sell_count = sum(1 for rec in recommendations if rec['action'] == 'SELL')\n            hold_count = sum(1 for rec in recommendations if rec['action'] == 'HOLD')\n            \n            total_stocks = len(recommendations)\n            \n            # Calculate average confidence\n            avg_confidence = np.mean([rec['confidence'] for rec in recommendations]) if recommendations else 0.5\n            \n            # Risk assessment\n            high_risk_count = sum(1 for rec in recommendations if rec['risk_level'] == 'high')\n            risk_percentage = (high_risk_count / total_stocks * 100) if total_stocks > 0 else 0\n            \n            if risk_percentage > 60:\n                risk_level = 'High'\n            elif risk_percentage > 30:\n                risk_level = 'Medium'\n            else:\n                risk_level = 'Low'\n            \n            # Portfolio score (1-10)\n            score_factors = []\n            \n            # Diversification factor\n            sectors = set()\n            for stock in portfolio:\n                try:\n                    company_info = market_service.get_company_info(stock['symbol'])\n                    sector = company_info.get('sector', 'Unknown')\n                    sectors.add(sector)\n                except:\n                    pass\n            \n            diversification_score = min(10, len(sectors) * 2)  # Max 10 points for 5+ sectors\n            score_factors.append(diversification_score)\n            \n            # Recommendation balance factor\n            balance_score = 10 - abs((buy_count - sell_count) / total_stocks * 10) if total_stocks > 0 else 5\n            score_factors.append(balance_score)\n            \n            # Confidence factor\n            confidence_score = avg_confidence * 10\n            score_factors.append(confidence_score)\n            \n            overall_score = np.mean(score_factors)\n            \n            # Generate insights\n            insights = []\n            \n            if diversification_score < 6:\n                insights.append(\"Consider diversifying across more sectors to reduce risk\")\n            \n            if sell_count > buy_count:\n                insights.append(\"Portfolio shows more sell signals - consider rebalancing\")\n            elif buy_count > sell_count:\n                insights.append(\"Portfolio shows growth opportunities with multiple buy signals\")\n            \n            if risk_percentage > 50:\n                insights.append(\"High concentration of risky assets - consider risk management\")\n            \n            if avg_confidence < 0.6:\n                insights.append(\"Market conditions show uncertainty - consider cautious approach\")\n            \n            if not insights:\n                insights.append(\"Portfolio appears well-balanced with reasonable risk distribution\")\n            \n            return {\n                'score': overall_score,\n                'risk_level': risk_level,\n                'diversification': f\"{diversification_score:.1f}/10\",\n                'insights': insights,\n                'buy_signals': buy_count,\n                'sell_signals': sell_count,\n                'hold_signals': hold_count,\n                'average_confidence': avg_confidence\n            }\n            \n        except Exception as e:\n            return {\n                'score': 5.0,\n                'risk_level': 'Medium',\n                'diversification': 'Unknown',\n                'insights': [f'Error assessing portfolio: {str(e)}'],\n                'buy_signals': 0,\n                'sell_signals': 0,\n                'hold_signals': 0,\n                'average_confidence': 0.5\n            }\n    \n    def _calculate_diversification_score(self, sector_allocation):\n        \"\"\"Calculate diversification score based on sector allocation\"\"\"\n        try:\n            if not sector_allocation:\n                return 0\n            \n            # Calculate Herfindahl-Hirschman Index (lower is more diversified)\n            hhi = sum((percentage/100) ** 2 for percentage in sector_allocation.values())\n            \n            # Convert to score (0-10, where 10 is perfectly diversified)\n            # Perfect diversification (equal weights) would have HHI of 1/n\n            # We'll use inverse relationship: lower HHI = higher score\n            diversification_score = max(0, min(10, (1 - hhi) * 10))\n            \n            return diversification_score\n            \n        except Exception as e:\n            return 0\n    \n    def generate_market_outlook(self, market_service):\n        \"\"\"Generate overall market outlook and recommendations\"\"\"\n        try:\n            # Get market indices data\n            indices_data = market_service.get_market_indices()\n            \n            # Get sector performance\n            sector_etfs = {\n                'Technology': 'XLK',\n                'Healthcare': 'XLV',\n                'Financials': 'XLF',\n                'Energy': 'XLE',\n                'Consumer Discretionary': 'XLY',\n                'Industrials': 'XLI'\n            }\n            \n            sector_performance = market_service.get_sector_performance(sector_etfs)\n            \n            # Prepare market summary for AI analysis\n            market_summary = f\"\"\"\n            Market Indices Performance (5-day):\n            \"\"\"\n            \n            for name, data in indices_data.items():\n                market_summary += f\"{name}: {data['change_percent']:+.2f}%\\n\"\n            \n            market_summary += \"\\nSector Performance (1-month):\\n\"\n            for sector, data in sector_performance.items():\n                market_summary += f\"{sector}: {data['performance']:+.2f}%\\n\"\n            \n            system_prompt = \"\"\"You are a market analyst providing outlook based on recent market performance.\n            \n            Analyze market conditions and provide:\n            - Overall market sentiment\n            - Key trends and patterns\n            - Investment themes to consider\n            - Risk factors to watch\n            \n            Respond in JSON format: {\n                \"market_sentiment\": \"bullish|bearish|neutral\",\n                \"confidence\": float (0 to 1),\n                \"key_trends\": [\"trend1\", \"trend2\"],\n                \"investment_themes\": [\"theme1\", \"theme2\"],\n                \"risk_factors\": [\"risk1\", \"risk2\"],\n                \"outlook\": \"detailed market outlook\",\n                \"time_horizon\": \"short|medium|long\"\n            }\"\"\"\n\n            prompt = f\"{system_prompt}\\n\\nAnalyze current market conditions:\\n{market_summary}\"\n            response = self.model.generate_content(prompt)\n            \n            result = json.loads(response.text)\n            return result\n            \n        except Exception as e:\n            return {\n                'market_sentiment': 'neutral',\n                'confidence': 0.5,\n                'key_trends': ['Analysis unavailable'],\n                'investment_themes': ['Diversified approach recommended'],\n                'risk_factors': ['Market uncertainty'],\n                'outlook': f'Unable to generate detailed outlook: {str(e)}',\n                'time_horizon': 'medium'\n            }\n","size_bytes":17187},"market_data.py":{"content":"import yfinance as yf\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nclass MarketDataService:\n    def __init__(self):\n        pass\n    \n    def get_stock_data(self, symbol, period=\"1y\"):\n        \"\"\"Fetch stock data from Yahoo Finance\"\"\"\n        try:\n            stock = yf.Ticker(symbol)\n            data = stock.history(period=period)\n            \n            if data.empty:\n                raise ValueError(f\"No data found for symbol: {symbol}\")\n            \n            return data\n            \n        except Exception as e:\n            print(f\"Error fetching data for {symbol}: {str(e)}\")\n            return pd.DataFrame()\n    \n    def get_company_info(self, symbol):\n        \"\"\"Get company information and key metrics\"\"\"\n        try:\n            stock = yf.Ticker(symbol)\n            info = stock.info\n            \n            # Extract key information\n            company_data = {\n                'symbol': symbol,\n                'longName': info.get('longName', symbol),\n                'sector': info.get('sector', 'Unknown'),\n                'industry': info.get('industry', 'Unknown'),\n                'marketCap': self._format_large_number(info.get('marketCap')),\n                'forwardPE': info.get('forwardPE'),\n                'trailingPE': info.get('trailingPE'),\n                'priceToBook': info.get('priceToBook'),\n                'debtToEquity': info.get('debtToEquity'),\n                'returnOnEquity': info.get('returnOnEquity'),\n                'revenueGrowth': info.get('revenueGrowth'),\n                'earningsGrowth': info.get('earningsGrowth'),\n                'currentPrice': info.get('currentPrice'),\n                'fiftyTwoWeekHigh': info.get('fiftyTwoWeekHigh'),\n                'fiftyTwoWeekLow': info.get('fiftyTwoWeekLow'),\n                'dividendYield': info.get('dividendYield'),\n                'payoutRatio': info.get('payoutRatio'),\n                'beta': info.get('beta'),\n                'averageVolume': info.get('averageVolume'),\n                'businessSummary': info.get('businessSummary', 'No summary available')\n            }\n            \n            return company_data\n            \n        except Exception as e:\n            print(f\"Error fetching company info for {symbol}: {str(e)}\")\n            return {'symbol': symbol, 'error': str(e)}\n    \n    def get_multiple_stocks(self, symbols, period=\"1mo\"):\n        \"\"\"Fetch data for multiple stocks\"\"\"\n        stock_data = {}\n        \n        for symbol in symbols:\n            try:\n                data = self.get_stock_data(symbol, period)\n                if not data.empty:\n                    stock_data[symbol] = data\n            except Exception as e:\n                print(f\"Error fetching {symbol}: {str(e)}\")\n                continue\n        \n        return stock_data\n    \n    def get_sector_performance(self, sector_etfs):\n        \"\"\"Get performance data for sector ETFs\"\"\"\n        sector_data = {}\n        \n        for sector, etf in sector_etfs.items():\n            try:\n                data = self.get_stock_data(etf, \"1mo\")\n                if not data.empty:\n                    start_price = data['Close'].iloc[0]\n                    end_price = data['Close'].iloc[-1]\n                    performance = ((end_price - start_price) / start_price) * 100\n                    \n                    sector_data[sector] = {\n                        'etf': etf,\n                        'performance': performance,\n                        'current_price': end_price,\n                        'data': data\n                    }\n            except Exception as e:\n                print(f\"Error fetching sector data for {sector}: {str(e)}\")\n                continue\n        \n        return sector_data\n    \n    def get_market_indices(self):\n        \"\"\"Get data for major market indices\"\"\"\n        indices = {\n            'S&P 500': '^GSPC',\n            'NASDAQ': '^IXIC', \n            'Dow Jones': '^DJI',\n            'Russell 2000': '^RUT',\n            'VIX': '^VIX'\n        }\n        \n        index_data = {}\n        \n        for name, symbol in indices.items():\n            try:\n                data = self.get_stock_data(symbol, \"5d\")\n                if not data.empty:\n                    current = data['Close'].iloc[-1]\n                    previous = data['Close'].iloc[0]\n                    change = ((current - previous) / previous) * 100\n                    \n                    index_data[name] = {\n                        'symbol': symbol,\n                        'current_value': current,\n                        'change_percent': change,\n                        'data': data\n                    }\n            except Exception as e:\n                print(f\"Error fetching index data for {name}: {str(e)}\")\n                continue\n        \n        return index_data\n    \n    def calculate_correlation(self, symbols, period=\"1y\"):\n        \"\"\"Calculate correlation matrix between stocks\"\"\"\n        try:\n            stock_data = {}\n            \n            for symbol in symbols:\n                data = self.get_stock_data(symbol, period)\n                if not data.empty:\n                    stock_data[symbol] = data['Close']\n            \n            if len(stock_data) < 2:\n                return pd.DataFrame()\n            \n            # Create DataFrame with closing prices\n            df = pd.DataFrame(stock_data)\n            \n            # Calculate daily returns\n            returns = df.pct_change().dropna()\n            \n            # Calculate correlation matrix\n            correlation_matrix = returns.corr()\n            \n            return correlation_matrix\n            \n        except Exception as e:\n            print(f\"Error calculating correlation: {str(e)}\")\n            return pd.DataFrame()\n    \n    def get_earnings_calendar(self, symbol):\n        \"\"\"Get earnings calendar for a stock\"\"\"\n        try:\n            stock = yf.Ticker(symbol)\n            calendar = stock.calendar\n            \n            if calendar is not None and isinstance(calendar, pd.DataFrame) and not calendar.empty:\n                return calendar\n            else:\n                return pd.DataFrame()\n                \n        except Exception as e:\n            print(f\"Error fetching earnings calendar for {symbol}: {str(e)}\")\n            return pd.DataFrame()\n    \n    def _format_large_number(self, number):\n        \"\"\"Format large numbers (market cap, etc.) for display\"\"\"\n        if number is None:\n            return \"N/A\"\n        \n        try:\n            number = float(number)\n            if number >= 1e12:\n                return f\"${number/1e12:.2f}T\"\n            elif number >= 1e9:\n                return f\"${number/1e9:.2f}B\"\n            elif number >= 1e6:\n                return f\"${number/1e6:.2f}M\"\n            else:\n                return f\"${number:,.2f}\"\n        except:\n            return \"N/A\"\n    \n    def get_financial_ratios(self, symbol):\n        \"\"\"Get key financial ratios for analysis\"\"\"\n        try:\n            stock = yf.Ticker(symbol)\n            info = stock.info\n            \n            ratios = {\n                'P/E Ratio': info.get('trailingPE'),\n                'Forward P/E': info.get('forwardPE'),\n                'P/B Ratio': info.get('priceToBook'),\n                'P/S Ratio': info.get('priceToSalesTrailing12Months'),\n                'Debt/Equity': info.get('debtToEquity'),\n                'ROE': info.get('returnOnEquity'),\n                'ROA': info.get('returnOnAssets'),\n                'Current Ratio': info.get('currentRatio'),\n                'Quick Ratio': info.get('quickRatio'),\n                'Profit Margin': info.get('profitMargins'),\n                'Operating Margin': info.get('operatingMargins'),\n                'Gross Margin': info.get('grossMargins')\n            }\n            \n            # Filter out None values\n            filtered_ratios = {k: v for k, v in ratios.items() if v is not None}\n            \n            return filtered_ratios\n            \n        except Exception as e:\n            print(f\"Error fetching financial ratios for {symbol}: {str(e)}\")\n            return {}\n","size_bytes":8097},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"docx>=0.2.4\",\n    \"google-genai>=1.29.0\",\n    \"google-generativeai>=0.8.5\",\n    \"numpy>=2.3.2\",\n    \"openai>=1.99.6\",\n    \"pandas>=2.3.1\",\n    \"pdfplumber>=0.11.7\",\n    \"plotly>=6.2.0\",\n    \"pypdf2>=3.0.1\",\n    \"python-docx>=1.2.0\",\n    \"sift-stack-py>=0.8.2\",\n    \"streamlit>=1.48.0\",\n    \"yfinance>=0.2.65\",\n]\n","size_bytes":459},"replit.md":{"content":"# FinDocAI - AI-Powered Financial Document Analysis\n\n## Overview\n\nFinDocAI is a comprehensive financial analysis platform that combines AI-powered document processing with real-time market data analysis to provide investment insights and recommendations. The application processes financial documents (PDFs, Word docs, text files), performs sentiment analysis, integrates live market data from Yahoo Finance, and generates AI-driven investment strategies. Built with Streamlit for the frontend and leveraging OpenAI's GPT-4o model for advanced financial analysis, the platform serves as an end-to-end solution for financial professionals and investors seeking data-driven investment decisions.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: Streamlit-based web application with multi-tab navigation\n- **Layout**: Wide layout configuration with expandable sidebar for navigation\n- **Components**: Four main sections - Document Upload & Q&A, Market Analysis, Investment Strategy, and Portfolio Dashboard\n- **Caching**: Uses Streamlit's `@st.cache_resource` decorator for service initialization to optimize performance\n\n### Backend Architecture\n- **Modular Design**: Service-oriented architecture with separate modules for distinct functionalities\n- **Core Services**:\n  - `FinancialAnalyzer`: Handles AI-powered financial analysis and sentiment processing\n  - `MarketDataService`: Manages real-time market data retrieval and company information\n  - `DocumentParser`: Processes various document formats (PDF, DOCX, TXT)\n  - `InvestmentStrategy`: Generates AI-driven investment recommendations\n\n### AI and Machine Learning Integration\n- **Primary AI Model**: OpenAI GPT-4o for financial analysis, sentiment analysis, and investment recommendations\n- **Analysis Capabilities**: \n  - Document sentiment analysis with confidence scoring\n  - Individual stock analysis and portfolio assessment\n  - AI-powered investment recommendations with risk assessment\n\n### Document Processing Pipeline\n- **Multi-format Support**: Handles PDF (PyPDF2), Word documents (docx), and text files\n- **Text Extraction**: Robust parsing with error handling and content validation\n- **Integration**: Seamless connection between document content and AI analysis services\n\n### Data Sources and Market Integration\n- **Market Data Provider**: Yahoo Finance API (yfinance) for stock prices, company information, and financial metrics\n- **Data Processing**: Pandas for data manipulation and NumPy for numerical computations\n- **Visualization**: Plotly Express and Plotly Graph Objects for interactive financial charts and dashboards\n\n### Investment Strategy Engine\n- **Portfolio Analysis**: Comprehensive portfolio health assessment with scoring system\n- **Risk Assessment**: Multi-level risk evaluation (low, medium, high)\n- **Recommendation System**: AI-driven buy/sell recommendations with detailed reasoning\n- **Performance Tracking**: Historical analysis and trend prediction capabilities\n\n## External Dependencies\n\n### AI and Language Models\n- **OpenAI API**: GPT-4o model for financial analysis, sentiment analysis, and investment strategy generation\n- **API Key Management**: Environment variable-based authentication for secure API access\n\n### Market Data Services\n- **Yahoo Finance (yfinance)**: Primary source for real-time stock data, company information, financial metrics, and historical market data\n- **Data Coverage**: Stock prices, market cap, financial ratios, earnings data, sector information, and trading volumes\n\n### Document Processing Libraries\n- **PyPDF2**: PDF document parsing and text extraction\n- **python-docx**: Microsoft Word document processing\n- **Built-in I/O**: Text file processing and BytesIO for file handling\n\n### Web Framework and Visualization\n- **Streamlit**: Complete web application framework with built-in components, caching, and state management\n- **Plotly**: Interactive charting library (Express and Graph Objects) for financial data visualization\n- **Pandas**: Data manipulation and analysis framework\n- **NumPy**: Numerical computing library for financial calculations\n\n### Development and Utility Libraries\n- **JSON**: Data serialization for AI model responses and configuration management\n- **DateTime**: Time-based analysis and historical data processing\n- **OS**: Environment variable management for API keys and configuration","size_bytes":4447}}}